<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/parada/src/main/java/grupo4/parada/repository/ParadaRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/parada/src/main/java/grupo4/parada/repository/ParadaRepository.java" />
              <option name="originalContent" value="package grupo4.parada.repository;&#10;&#10;import grupo4.parada.model.Parada;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface ParadaRepository extends JpaRepository&lt;Parada, Long&gt; {&#10;&#10;    /*La fórmula del Haversine calcula la distancia más corta (aérea) entre dos puntos&#10;    en una esfera (la Tierra) utilizando sus coordenadas de latitud y longitud.&#10;    Convierte la distancia angular calculada con trigonometría en una distancia lineal&#10;    (kilómetros o millas) multiplicándola por el radio de la Tierra.*/&#10;    @Query(value =&#10;            &quot;SELECT * &quot; +&#10;            &quot;FROM parada &quot; +&#10;            &quot;WHERE ( &quot; +&#10;            &quot;  6371 * acos( &quot; +&#10;            &quot;    LEAST(1.0, GREATEST(-1.0, &quot; +&#10;            &quot;      cos(radians(:latitudUsuario)) * cos(radians(latitud)) &quot; +&#10;            &quot;      * cos(radians(longitud) - radians(:longitudUsuario)) + &quot; +&#10;            &quot;      sin(radians(:latitudUsuario)) * sin(radians(latitud)) &quot; +&#10;            &quot;    )) &quot; +&#10;            &quot;  ) &quot; +&#10;            &quot;) &lt; :radio &quot; +&#10;            &quot;ORDER BY ( &quot; +&#10;            &quot;  6371 * acos( &quot; +&#10;            &quot;    LEAST(1.0, GREATEST(-1.0, &quot; +&#10;            &quot;      cos(radians(:latitudUsuario)) * cos(radians(latitud)) &quot; +&#10;            &quot;      * cos(radians(longitud) - radians(:longitudUsuario)) + &quot; +&#10;            &quot;      sin(radians(:latitudUsuario)) * sin(radians(latitud)) &quot; +&#10;            &quot;    )) &quot; +&#10;            &quot;  ) &quot; +&#10;            &quot;)&quot;,&#10;            nativeQuery = true)&#10;    List&lt;Parada&gt; findParadasCercanas(&#10;            @Param(&quot;latitudUsuario&quot;) Double latitudUsuario,&#10;            @Param(&quot;longitudUsuario&quot;) Double longitudUsuario,&#10;            @Param(&quot;radio&quot;) Double radio);&#10;}&#10;" />
              <option name="updatedContent" value="package grupo4.parada.repository;&#10;&#10;import grupo4.parada.model.Parada;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface ParadaRepository extends JpaRepository&lt;Parada, Long&gt; {&#10;&#10;    /*La fórmula del Haversine calcula la distancia más corta (aérea) entre dos puntos&#10;    en una esfera (la Tierra) utilizando sus coordenadas de latitud y longitud.&#10;    Convierte la distancia angular calculada con trigonometría en una distancia lineal&#10;    (kilómetros o millas) multiplicándola por el radio de la Tierra.*/&#10;    @Query(value =&#10;            &quot;SELECT * &quot; +&#10;            &quot;FROM parada &quot; +&#10;            &quot;WHERE ( &quot; +&#10;            &quot;  6371 * acos( &quot; +&#10;            &quot;    LEAST(1.0, GREATEST(-1.0, &quot; +&#10;            &quot;      cos(radians(:latitudUsuario)) * cos(radians(latitud)) &quot; +&#10;            &quot;      * cos(radians(longitud) - radians(:longitudUsuario)) + &quot; +&#10;            &quot;      sin(radians(:latitudUsuario)) * sin(radians(latitud)) &quot; +&#10;            &quot;    )) &quot; +&#10;            &quot;  ) &quot; +&#10;            &quot;) &lt; :radio &quot; +&#10;            &quot;ORDER BY ( &quot; +&#10;            &quot;  6371 * acos( &quot; +&#10;            &quot;    LEAST(1.0, GREATEST(-1.0, &quot; +&#10;            &quot;      cos(radians(:latitudUsuario)) * cos(radians(latitud)) &quot; +&#10;            &quot;      * cos(radians(longitud) - radians(:longitudUsuario)) + &quot; +&#10;            &quot;      sin(radians(:latitudUsuario)) * sin(radians(latitud)) &quot; +&#10;            &quot;    )) &quot; +&#10;            &quot;  ) &quot; +&#10;            &quot;)&quot;,&#10;            nativeQuery = true)&#10;    List&lt;Parada&gt; findParadasCercanas(&#10;            @Param(&quot;latitudUsuario&quot;) Double latitudUsuario,&#10;            @Param(&quot;longitudUsuario&quot;) Double longitudUsuario,&#10;            @Param(&quot;radio&quot;) Double radio);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>